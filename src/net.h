/* net.h - pokgame */
#ifndef POKGAME_NET_H
#define POKGAME_NET_H
#include "types.h"

/* constants */
enum pok_net_constants
{
    UNUSED_NETOBJ_ID = 0
};

/* exception ids generated by this module */
enum pok_ex_net
{
    pok_ex_net_unspec, /* unspecified error */
    pok_ex_net_interrupt, /* read/write interruption */
    pok_ex_net_wouldblock, /* asynchronous call returned/sent no data */
    pok_ex_net_pending, /* call did not return/send enough data (some data was still received) */
    pok_ex_net_brokenpipe, /* write to unconnected pipe */
    pok_ex_net_endofcomms, /* end of communication sent on IO device */
    pok_ex_net_noroom, /* the data source attempted to buffer bytes left over from a write operation but there was no room */

    /* these are flagged when 'pok_data_source_new_file' fails */
    pok_ex_net_file_does_not_exist,
    pok_ex_net_file_already_exist,
    pok_ex_net_file_permission_denied,
    pok_ex_net_file_bad_path
};

/* IPv4 network address information */
struct pok_network_address
{
    byte_t ipv4[4];
    uint16_t port;
};
void pok_network_address_init(struct pok_network_address* addr,const char* host,const char* port);

/* filemodes for file 'datasource' */
enum pok_filemode
{
    pok_filemode_create_new, /* file must be new */
    pok_filemode_create_always, /* create new file; file can preexist but is truncated and overwritten */
    pok_filemode_open_existing /* file must preexist */
};

/* bitmask input-output modes for any 'datasource' */
enum pok_iomode
{
    pok_iomode_read = 0x01,
    pok_iomode_write = 0x02,
    pok_iomode_full_duplex = 0x03
};

/* a 'data_source' is an abstraction to a lower-level input-output device supported by the 
   operating system; to the rest of the application it is an opaque type used to receive
   and send data to another process, either local or remote */
struct pok_data_source;
struct pok_data_source* pok_data_source_new_standard();
struct pok_data_source* pok_data_source_new_local_named(const char* name);
struct pok_data_source* pok_data_source_new_local_anon();
struct pok_data_source* pok_data_source_new_network(struct pok_network_address* address);
struct pok_data_source* pok_data_source_new_file(const char* filename,enum pok_filemode mode,enum pok_iomode access);
byte_t* pok_data_source_read(struct pok_data_source* dsrc,size_t bytesRequested,size_t* bytesRead);
bool_t pok_data_source_read_to_buffer(struct pok_data_source* dsrc,void* buffer,size_t bytesRequested,size_t* bytesRead);
char pok_data_source_peek(struct pok_data_source* dsrc); /* these return (char) -1 on failure so use them for plain text */
char pok_data_source_peek_ex(struct pok_data_source* dsrc,size_t lookahead);
char pok_data_source_pop(struct pok_data_source* dsrc);
bool_t pok_data_source_write(struct pok_data_source* dsrc,const byte_t* buffer,size_t size,size_t* bytesWritten);
void pok_data_source_buffering(struct pok_data_source* dsrc,bool_t on);
void pok_data_source_unread(struct pok_data_source* dsrc,size_t size);
bool_t pok_data_source_save(struct pok_data_source* dsrc,const byte_t* buffer,size_t size);
bool_t pok_data_source_flush(struct pok_data_source* dsrc);
enum pok_iomode pok_data_source_getmode(struct pok_data_source* dsrc);
void pok_data_source_free(struct pok_data_source* dsrc);

/* higher-level data-stream operations */
bool_t pok_data_stream_fread(struct pok_data_source* dsrc,int* cnt,const char* format, ...);
bool_t pok_data_stream_read_byte(struct pok_data_source* dsrc,byte_t* dst);
bool_t pok_data_stream_read_uint16(struct pok_data_source* dsrc,uint16_t* dst);
static inline bool_t pok_data_stream_read_int16(struct pok_data_source* dsrc,int16_t* dst)
{ return pok_data_stream_read_uint16(dsrc,(uint16_t*)dst); }
bool_t pok_data_stream_read_uint32(struct pok_data_source* dsrc,uint32_t* dst);
static inline bool_t pok_data_stream_read_int32(struct pok_data_source* dsrc,int32_t* dst)
{ return pok_data_stream_read_uint32(dsrc,(uint32_t*)dst); }
bool_t pok_data_stream_read_uint64(struct pok_data_source* dsrc,uint64_t* dst);
static inline bool_t pok_data_stream_read_int64(struct pok_data_source* dsrc,int64_t* dst)
{ return pok_data_stream_read_uint64(dsrc,(uint64_t*)dst); }
bool_t pok_data_stream_read_string(struct pok_data_source* dsrc,char* dst,size_t numBytes);
bool_t pok_data_stream_read_string_ex(struct pok_data_source* dsrc,struct pok_string* dst);
bool_t pok_data_stream_fwrite(struct pok_data_source* dsrc,int* cnt,const char* format, ...);
bool_t pok_data_stream_write_byte(struct pok_data_source* dsrc,byte_t src);
bool_t pok_data_stream_write_uint16(struct pok_data_source* dsrc,uint16_t src);
static inline bool_t pok_data_stream_write_int16(struct pok_data_source* dsrc,int16_t src)
{ return pok_data_stream_write_uint16(dsrc,src); }
bool_t pok_data_stream_write_uint32(struct pok_data_source* dsrc,uint32_t src);
static inline bool_t pok_data_stream_write_int32(struct pok_data_source* dsrc,int32_t src)
{ return pok_data_stream_write_uint32(dsrc,src); }
bool_t pok_data_stream_write_uint64(struct pok_data_source* dsrc,uint64_t src);
static inline bool_t pok_data_stream_write_int64(struct pok_data_source* dsrc,int64_t src)
{ return pok_data_stream_write_uint64(dsrc,src); }
bool_t pok_data_stream_write_string(struct pok_data_source* dsrc,const char* src);
bool_t pok_data_stream_write_string_ex(struct pok_data_source* dsrc,const char* src,size_t numBytes);
bool_t pok_data_stream_write_string_obj(struct pok_data_source* dsrc,const struct pok_string* src);

/* flags for the sending/receiving of a network object */
enum pok_network_result
{
    pok_net_completed, /* object was successfully sent/received */
    pok_net_incomplete, /* object was not completely sent/received */
    pok_net_failed, /* object failed to send/be received; exception is generated */
    pok_net_failed_protocol, /* peer did not adhere to protocol; exception is generated */
    pok_net_failed_internal, /* object failed to send/be received but due to another reason; exception is generated */
    pok_net_already /* object was marked as already sent */
};

/* network object information structure; defines the progress 
   of sending a network object; the implementation may use
   this object in any way it sees fit */
struct pok_netobj_readinfo
{
    uint16_t fieldCnt; /* field counter */
    uint16_t fieldProg; /* field progress */
    uint16_t depth[2]; /* progress within current field; 2 variables allow multiple dimensions to the field */

    /* form a linked list to represent netobj info for potential substructures */
    struct pok_netobj_readinfo* next;

    /* auxilary data object; will be freed automatically if set */
    void* aux;
};
struct pok_netobj_readinfo* pok_netobj_readinfo_new();
void pok_netobj_readinfo_free(struct pok_netobj_readinfo* info);
void pok_netobj_readinfo_init(struct pok_netobj_readinfo* info);
void pok_netobj_readinfo_delete(struct pok_netobj_readinfo* info);
void pok_netobj_readinfo_reset(struct pok_netobj_readinfo* info);
enum pok_network_result pok_netobj_readinfo_process(struct pok_netobj_readinfo* info);
enum pok_network_result pok_netobj_readinfo_process_depth(struct pok_netobj_readinfo* info,int index);
bool_t pok_netobj_readinfo_alloc_next(struct pok_netobj_readinfo* info);

/* enumerate the network object kinds */
enum pok_netobj_kind
{
    pok_netobj_unknown,
    pok_netobj_world,
    pok_netobj_map,
    pok_netobj_mapchunk,
    pok_netobj_character
};

/* represents the superclass for all dynamic network objects */
struct pok_netobj
{
    uint32_t id; /* if 0 then id is not used (object is not being tracked) */
    enum pok_netobj_kind kind;
};
void pok_netobj_default(struct pok_netobj* netobj);
void pok_netobj_default_ex(struct pok_netobj* netobj,enum pok_netobj_kind kind);
void pok_netobj_delete(struct pok_netobj* netobj);
enum pok_network_result pok_netobj_netread(struct pok_netobj* netobj,struct pok_data_source* dsrc,struct pok_netobj_readinfo* info);

/* network object functionality: we need to track changes to dynamic network objects */
void network_object_load();
void network_object_unload();
struct pok_netobj* network_object_lookup(uint32_t id);

#endif
